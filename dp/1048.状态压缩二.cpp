/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
历经千辛万苦，小Hi和小Ho终于到达了举办美食节的城市！虽然人山人海，但小Hi和小Ho仍然抑制不住兴奋之情，他们放下行李便投入
到了美食节的活动当中。美食节的各个摊位上各自有着非常多的有意思的小游戏，其中一个便是这样子的：小Hi和小Ho领到了一个大小
为N*M的长方形盘子，他们可以用这个盒子来装一些大小为2*1的蛋糕。但是根据要求，他们一定要将这个盘子装的满满的，一点缝隙也
不能留下来，才能够将这些蛋糕带走。

这么简单的问题自然难不倒小Hi和小Ho，于是他们很快的就拿着蛋糕离开了~
但小Ho却不只满足于此，于是他提出了一个问题——他们有多少种方案来装满这个N*M的盘子呢？
值得注意的是，这个长方形盘子的上下左右是有区别的，如在N=4, M=3的时候，下面的两种方案被视为不同的两种方案哦！

提示：我们来玩拼图吧！不过不同的枚举方式会导致不同的结果哦！

输入
每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第一行为两个正整数N、M，表示小Hi和小Ho拿到的盘子的大小。
对于100%的数据，满足2<=N<=1000, 3<=m<=5。<>

输出
考虑到总的方案数可能非常大，只需要输出方案数除以1000000007的余数。

样例输入
2 4

样例输出
5

解题思路：
参考：http://blog.csdn.net/hopeztm/article/details/7841917

这个题目类属于状态压缩DP，对于状态压缩DP，其实最简单的理解就是把状态用比特位的形式表示出来，我们会在下面用例子来说明。
假如现在我们在铺砖 位置(i, j), 并且假设之前的位置已经铺设好的了，在这个位置，我们的选择：
1. 不用铺砖了，可能在(i-1, j)的时刻已经被竖着铺上了，然后考虑的是（i， j+1）
2. 横铺砖，将(i, j+1）也铺上了，然后考虑的是(i, j+2)
3. 竖着铺砖，（将i，j）和（i+1，j）铺上一个竖立的转头。

所以我们如下翻译我们的选择，在位置(i, j) 如果我们选择横着贴砖，那么将(i, j), (i, j+1)都填写成1， 如果竖着贴砖，我们
将(i,j)填写成0， 将(i+1, j)填写成1. 为什么要这么计数呢，我觉得应该这样理解：
1. 在横着贴砖的时候，(i, j), (i, j+1) 都是1，这个值其实对下一行如何选择没有影响。
2. 竖着贴砖的第二个，我们也选择了1， 因为这个砖头结束了，对下一行如何选择依然没有影响。
3. 而竖着的第一个砖头，这个砖头是对下面有影响的，如果(i,j)是0，那么(i+1, j)只有是1的情况下才能满足条件。

（这涉及到接下来的 状态兼容性问题）

对于竖着贴砖为什么这样选择，这样选择的一个好处是，我们在处理最后一行的时候，可以保证最后一行都是1， 因为最后一行绝对不能
成为 竖砖开始，所以很容易取得最后的解。最后砖头铺满的状态，一定是最后一行全是1。

我们用DP(i,j) 表示如下含义： 当第i行，达到状态j的时候，所能采取的方案数目，初始值为0。 所以明显我们的最后目的是求
DP(N, 2^(M-1)-1);

我们再来简单的分析一下为什么问题可以满足动态规划， 假如现在分析的对象是 DP(i,j)， 那么这一行有多少种铺设办法是和上一行相
关的，如果上一行的某个状态DP(i-1,k) 可以达到 DP(i, j) 我们认为这两个状态是兼容的，如果DP(i-1,k)和DP(i, j)兼容并且 
DP(i-1, k)有S种铺设方案，那么DP(i, j)就可以从DP(i-1, k)这条路径中获得S个方案。当然这里k的取值可以是0 ~ 2^(M-1)-1种取值。

现在我们来理解一下，什么叫做 j, k 兼容。
其实我们在上面已经基本给出分析， 如果我们现在铺设 (i,x) x这里表示第i行，第x列
1. 如果值 i 行，j 在x位上的值是0：
    那么第 i-1行，j的值在x位上一定是1。因为不可能在同一列相邻的位置铺两个竖着的。第一个如果
    满足，下一步测试的就是(i, x+1), 否则直接返回不兼容。

2. 如果值 i  行，j在x位置的值是1：
    那么有可能有两种情况：
    1. (i-1, x)是0， 这个时候一定是竖着铺设了，下一步检测的是(i, x + 1)
    2.  (i-1, x) 是1， 如果是这样的话，那么(i, x)一定是要选择横着铺了，那么(i,x+1)也一定是1，并且(i-1, x + 1)一定是1
    （如果是0，就是竖着铺了），如果不满足就返回不兼容，满足条件 就测试(i, x + 2)

如何判断第一行是否可行：
对于第一行的某个位置i,如果在该位置竖着放，那么dp[1][i]=1, 如果在该位置横着放，则dp[1][i] = dp[1][i+1]=1. 如果最后只
剩下一个位置，则只能竖着放。
*/

#include<iostream>
#include<cstdio>
using namespace std;
const int maxn = 1005;
const int maxm = 1<<5;
const int MOD = 1000000007;

int dp[maxn][maxm];

bool firstLineValid(int state,int M){
    for(int i=0; i<M;){
        if( (state & (1<<i)) == 0) ++i; //如果该位置为0,则该位置为竖着放的，继续处理下一个位置
        else if( (i == M-1) || !(state & (1<<(i+1)) ) ) return false; //最后一个位置没有竖着放，或者两个1没有连续出现
        else i+=2; //横着放，有两个连续的1
    }
    return true;
}
/*
1.当curRow[i]=0 时，lastRow[i]一定为1,否则不兼容
2.当curRow[i]=1 时，
    1.如果lastRow[i]=0,说明上一行在i位置是竖着放的，直接继续考虑下一个位置,i+1
    2.如果lastRow[i]=1,说明curRow[i]=1是由于在当前位置横着放蛋糕产生的，所以curRow[i+1]必须也是1，
      并且因为在当前行的i位置横着放的，所以在上一行的i+1位置处不能竖着放蛋糕(否则与当前行在i位置的蛋糕重合),
      所有lastRow[i+1]也必须为1
*/

bool compatible(int curRow, int lastRow,int M){
    for(int i=0; i<M;){
        if( (curRow & (1<<i)) == 0){
            if( (lastRow & (1<<i)) == 0) return false;
            ++i;
        }
        else{ //curRow[i] = 1
            if( (lastRow & (1<<i)) == 0) ++i;
            else if( (i == M-1) || (curRow & (1<<(i+1)))==0 || (lastRow & (1<<(i+1)))==0 ) return false; //lastRow[i] = 1
            else i+=2; //当前位置横着放，跨越连续两个1
        }
    }
    return true;
}

int main(){
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    int N,M;
    scanf("%d%d",&N,&M);
    if(N<M) swap(N,M);
    int allState = (1<<M)-1;
    for(int j=0; j<=allState; ++j){
        if(firstLineValid(j, M)) dp[1][j] = 1;
    }

    for(int i=2; i<=N; ++i){ //计算第i行所有可行的填充方法总数
        //计算第i行的状态j与第i-1行的状态k是否兼容。
        //如果兼容，则dp[i][j]可以从第i-1行的状态k获得dp[i-1][k]种方案。
        for(int j=0; j<=allState; ++j){
            for(int k=0; k<=allState; ++k){
                if(compatible(j,k,M)){
                    dp[i][j] += dp[i-1][k];
                    dp[i][j] %= MOD;
                }
            }
        }
    }
    printf("%d\n",dp[N][allState]);

    return 0;
}