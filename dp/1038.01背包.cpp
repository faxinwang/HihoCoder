/*
时间限制:20000ms
单点时限:1000ms
内存限制:256MB
描述
且说上一周的故事里，小Hi和小Ho费劲心思终于拿到了茫茫多的奖券！而现在，终于到了小Ho领取奖励的时刻了！
小Ho现在手上有M张奖券，而奖品区有N件奖品，分别标号为1到N，其中第i件奖品需要need(i)张奖券进行兑换，
同时也只能兑换一次，为了使得辛苦得到的奖券不白白浪费，小Ho给每件奖品都评了分，其中第i件奖品的评分值
为value(i),表示他对这件奖品的喜好值。现在他想知道，凭借他手上的这些奖券，可以换到哪些奖品，使得这些奖
品的喜好值之和能够最大。

提示一：合理抽象问题、定义状态是动态规划最关键的一步

提示二：说过了减少时间消耗，我们再来看看如何减少空间消耗

输入
每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第一行为两个正整数N和M,表示奖品的个数，以及小Ho手中的奖券数。
接下来的n行描述每一行描述一个奖品，其中第i行为两个整数need(i)和value(i)，意义如前文所述。

测试数据保证
对于100%的数据，N的值不超过500，M的值不超过10^5
对于100%的数据，need(i)不超过2*10^5, value(i)不超过10^3

输出
对于每组测试数据，输出一个整数Ans，表示小Ho可以获得的总喜好值。

样例输入
5 1000
144 990
487 436
210 673
567 58
1056 897

样例输出
2099

解题思路：
设dp[i][j]表示当背包容量为j，考虑的物品数为i时所能获得的最大价值.
则当考虑第i+1个物品, 背包容量为j时，所能获得的最大值为 dp[i+1][j] = max(dp[i][j], dp[i][j-need]+value)
从公式可以看出，每次计算当前物品加入所能获得的最大值时，需要用到上一次计算得到的最大值，
所以我们从右边开始填数组，就可以利用到上次计算的最大值(从左边开始填数组会覆盖到上次计算的结果)，这样
就可以只使用一维数组就计算出结果。

f[i][v]表示把前i件物品放入容量为v的背包时的最大代价。

f[i-1][v-c[i]]表示把前i - 1件物品放入容量为v的背包时的最大代价.

dp方程： f[i][v] = max(f[i - 1][v],f[i - 1][v - weight[i]] + Value[i])    

在01背包中，v变化的区间是逆序循环的原因：要保证由状态f[i-1][v-c[i]]递推状态f[i][v]时，f[i-1][v-c[i]]没有
放入第i件物品。之后，在第i循环时，放入一件第i件物品。

*/

#include<iostream>
#include<cstdio>
using namespace std;
const int maxc = 1e5+5;

int dp[maxc]; //dp[j]表示背包容量为j时对于所给定物品，所能取得的最大价值。

int main(){
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    int N,C,need,value;
    scanf("%d%d",&N,&C);
    for(int i=0; i<N; ++i){
        scanf("%d%d",&need,&value);
        for(int j=C; j>=need; --j){
            if( dp[j] < dp[j-need] + value ) dp[j] = dp[j-need] + value;
        }
    }
    printf("%d\n", dp[C]);

    return 0;
}