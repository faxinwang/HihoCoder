/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即
将举行美食节！但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。不仅
如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致
这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。小Hi和小Ho本着礼让他们的心情——当然还因
为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车
厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦
相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。

将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多
的清扫垃圾。小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客
在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是
值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被
惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可
能多的垃圾。

提示一：无论是什么动态规划，都需要一个状态转移方程！
提示二：好像什么不对劲？状态压缩哪里去了？

输入
每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第一行为三个正整数N、M和Q，意义如前文所述。
每组测试数据的第二行为N个整数，分别为W1到WN，代表每一个位置上的垃圾数目。
对于100%的数据，满足N<=1000, 2<=M<=10,1<=Q<=M, Wi<=100

输出
对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。

样例输入
5 2 1
36 9 80 69 85 

样例输出
201

解题思路:
dp(i,S)表示前i个位置，(i-m+1)到i这些位置是否被打扫如S集合中所表示的那样时，可以打扫的最多垃圾数。
状态转移：
当i位置被选中时，dp(i,S) = max(dp(i-1,S-{i被选中否} +{i-m被选中}),  dp(i-1,S-{i被选中否} +{i-m未被选中}) ) + w(i)
当i位置未被选中时，dp(i,S) = max(dp(i-1,S-{i被选中否} + {i-m被选中}),  dp(i-1,S-{i被选中否} + {i-m未被选中}) )

我们用dp[i][j]表示在第i个位置上，j是一个二进制状态，表示包括当前位置的前M-1个位置上的数是否被选取。
例如j=10101表示第1,3,5个位置选择，2,4位置不选。
那么dp[i][s] = max( dp[i-1][last]+w[i] , dp[i][s] ),我们枚举可行的last,并判断last中含有1的个数，
如果last中含有q个1，第i个位置只能不选了；否则既可以不选也可以选。
*/

#include<iostream>
#include<cstdio>
using namespace std;
const int maxn = 1005;
int N,M,Q;
int dp[maxn][1<<10]; // dp[i][j]表示从前i个位置，在状态j所表示的状态中所能打扫垃圾的最大数目
int w[maxn];

int num(int x){
    int cnt = 0;
    while(x){
        cnt += x&1;
        x >>= 1;
    }
    return cnt;
}

int main(){
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    scanf("%d%d%d",&N,&M,&Q);
    for(int i=1; i<=N; ++i) scanf("%d",w+i);
    if(M == Q){
        int ans = 0;
        for(int i=1; i<=N; ++i) ans += w[i];
        printf("%d\n",ans);
    }
    else{
        int add = 1<<(M-1);
        int ans = 0;
        for(int i=1; i<=N; ++i)
        {
            //枚举前M个位置的状态，当i<m时，就只能枚举前i个位置了
            for(int j=0,n=(1<<min(i,M)); j<=n; ++j)
            {
                if(num(j) > Q) continue;
                if( ~j & 1)//判断j这个状态是否包含了i位置   
                    dp[i][j] = max(dp[i-1][j>>1], dp[i-1][ (j>>1) + add] );
                else
                    dp[i][j] = max(dp[i-1][j>>1], dp[i-1][ (j>>1) + add] ) + w[i];
            }
        }
        for(int i=0,n=(1<<min(M,N)); i<=n; ++i) ans = max(ans, dp[N][i]);
        printf("%d\n",ans);
    }


    return 0;
}