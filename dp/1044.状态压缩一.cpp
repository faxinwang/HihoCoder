/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即
将举行美食节！但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。不仅
如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致
这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。小Hi和小Ho本着礼让他们的心情——当然还因
为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车
厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦
相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。

将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多
的清扫垃圾。小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客
在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是
值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被
惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可
能多的垃圾。

提示一：无论是什么动态规划，都需要一个状态转移方程！
提示二：好像什么不对劲？状态压缩哪里去了？

输入
每个测试点（输入文件）有且仅有一组测试数据。
每组测试数据的第一行为三个正整数N、M和Q，意义如前文所述。
每组测试数据的第二行为N个整数，分别为W1到WN，代表每一个位置上的垃圾数目。
对于100%的数据，满足N<=1000, 2<=M<=10,1<=Q<=M, Wi<=100

输出
对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。

样例输入
5 2 1
36 9 80 69 85 

样例输出
201

解题思路:
dp[i][j]: j是一个二进制状态,表示第i个元素和i前面的M-1个元素选择的信息, dp[i][j]表示在j的状态下子问题为i
的一个解,即前i个元素在题目的限制条件下,得到的一个解. 那么答案就是dp[N][j]中最大的一个.(这里的j是
一个状态集合, 表示所有合法的状态).

这里j从最右边开始的第1位表示当前第i个元素的选择状态,1为选择,0为不选择.
j从最右边开始的第2位表示第i个元素前面一个元素的选择状态, 依次类推.

现在假设d[i-1][j]都已经计算出来了, 那么如何计算d[i][j]呢.
这就要看d[i-1][j]中的j里面已经选择的元素的个数, 如果已经选择了Q个, 则当前第i个元素只能不选.
dp[i][next] = dp[i-1][j]. (next是由dp[i-1][j]中的状态j转移过来的,具体看代码)

如果前面选择的没有超过Q个, 则当前第i个元素可以选择也可以不选.不选的话,状态转移方程和上面的一样,
选择的话,有
dp[i][next|1] = max(dp[i][next|1], dp[i-1][j] + w[i])
*/

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int maxn = 1005;
int N,M,Q;
int dp[maxn][1<<10]; // dp[i][j]表示从前i个位置，在状态j所表示的状态中所能打扫垃圾的最大数目
int w[maxn];  //要选择的序列
int state[1<<10]; //保存所有的合法状态(决策信息)
int num[1<<10]; //num[i]记录状态i里面1的个数
int S = 0; //记录可行状态的数量

//计算状态x里面选则的位置的个数,1表示选择了,0表示没有选
int count(int x){
    int cnt = 0;
    while(x){
        cnt += x&1;
        x >>= 1;
    }
    return cnt;
}

//计算出所有可行的状态,连续m个位置中选择的个数不能超过Q个.
void init_states()
{
    for(int s=0, n=1<<(M-1); s<n; ++s)
    {
        int t = count(s);
        if(t > Q) continue; //连续M-1位里面1的个数超过了Q个, 不合法
        state[S++] = s;
        num[s] = t; //记录状态s里面的1的个数为t
    }
}

int main(){
#ifdef WFX
freopen("in.txt","r",stdin);
#endif

    scanf("%d%d%d",&N,&M,&Q);
    for(int i=1; i<=N; ++i) scanf("%d",w+i);
    if(M == Q){ //每连续M个里面可以选择M个, 所以所有元素都选择时结果最大.
        int ans = 0;
        for(int i=1; i<=N; ++i) ans += w[i];
        printf("%d\n",ans);
    }
    else{
        init_states();
        int all=(1<<(M-1))-1; //低位连续M-1个1
        for(int i=1; i<=N; ++i)//从第一个元素开始, 枚举该元素选和不选两种状态.
        {
            //枚举所有合法的状态,每个状态里面保存了前面M-1个元素有没有选择的信息
            //如果前面的M-1个元素里面已经选择了Q个元素, 则当前元素不能选择,否则可以选择
            //任何状态下, 当前元素都可以不选择
            for(int j=0; j<S; ++j)
            {   
                int s = state[j];
                int next = (s<<1) & all; //新的状态
                //如果当前元素可以选择, 则计算在选择该元素的决策下能得到的最优解
                //状态next|1 表示选择的元素中加入了第i个元素
                //next|1之前可能已经计算过,所以更新的时候要取已有值与新计算得到的一个解中的较大者
                if(num[s] < Q) dp[i][next|1] = max(dp[i][next|1], dp[i-1][s] + w[i] );
                
                //计算在不选择当前元素的决策下能得到的最优解, 为前i-1个元素在所有决策中的最优解.
                dp[i][next] = max(dp[i][next], dp[i-1][s]); 
            }
        }
        
        int ans = 0;
        for(int j=0; j<S; ++j) ans = max(ans, dp[N][state[j]]);

        printf("%d\n",ans);
    }

    return 0;
}