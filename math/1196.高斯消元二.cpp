/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
在上一回中，小Hi和小Ho趁着便利店打折，买了一大堆零食。当他们结账后，看到便利店门口还有其他的活动。

店主：买了东西还可以参加游戏活动哦，如果能够完成游戏还有额外的奖品。

小Hi和小Ho赶紧凑了过去。

店主放了一块游戏板在店门口，有5行6列格子。左上角为坐标(1,1)。一部分格子是亮着的，另一部分是暗着的。

week57_1.PNG

 当按下某一个格子时，它和上下左右4个格子的状态就会改变。原来亮着的格子变成暗的，原来暗的格子会变亮。
 比如下图中按下标记有红叉的格子后，绿色虚线区域内的格子状态都会改变：
week57_2.PNG

店主给出初始的状态，参加游戏的人员需要通过按下某些格子，让游戏板上所有的灯都亮起来就可以赢得奖品。

小Ho：这不就是开关灯问题么，看我来解决它！

本题改编自ACMICPC Greater New York 2002 EXTENDED LIGHTS OUT

--------------------------------------------------------
提示：异或方程组
小Ho在游戏板上忙碌了30分钟，任然没有办法完成，于是他只好求助于小Hi。

小Ho：小Hi，这次又该怎么办呢？

小Hi：让我们来分析一下吧。

首先对于每一个格子的状态，可能会对它造成影响的是其自身和周围4个格子，这五个格子被按下
的总次数也就等于该格子所改变的总次数。

对于任意一个格子，如果这个格子改变了偶数次状态，则等价于没有发生改变。

我们可以将1看作格子亮着，0看作格子暗着，每改变1次就加1，最后格子的状态等于其总数值 MOD 2。

则其运算结果刚好满足异或运算，即每改变一次等于状态值 xor 1。

同样的对于一个格子和它周围的4个格子来说，若格子被按下偶数次，它自身和周围4个格子的状态也
等于没有发生改变。所以我们可以知道：任意一个格子至多被按下一次。

假设有数组x[1..30]，分别表示这30个格子是否按下1次，若按下则x[i]=1，否则x[i]=0。

则对于1个格子，他最后的状态为：

当前状态 = 初始状态 xor (a[1] * x[1]) xor (a[2] * x[2]) xor ... xor (a[30] * x[30])
其中a[i]表示格子i是否会对当前格子产生影响，若能够则a[i] = 1，否则a[i] = 0

对方程进行变换有：

(a[1] * x[1]) xor (a[2] * x[2]) xor ... xor (a[30] * x[30]) = 当前状态 xor 初始状态
因为我们的目标是要让所有等格子都为亮的状态，故我们需要让 当前状态 = 1，则：

(a[1] * x[1]) xor (a[2] * x[2]) xor ... xor (a[30] * x[30]) = 1 xor 初始状态
不妨设y = 1 xor 初始状态：

(a[1] * x[1]) xor (a[2] * x[2]) xor ... xor (a[30] * x[30]) = y
对于所有的格子，我们可以连立出方程组：

(a[ 1][1] * x[1]) xor (a[ 1][2] * x[2]) xor ... xor (a[ 1][30] * x[30]) = y[ 1]
(a[ 2][1] * x[1]) xor (a[ 2][2] * x[2]) xor ... xor (a[ 2][30] * x[30]) = y[ 2]
                                            ...
(a[30][1] * x[1]) xor (a[30][2] * x[2]) xor ... xor (a[30][30] * x[30]) = y[30]
		
到此，我们的目标就是求出一个x[1..30]，使得上面的方程组成立。

小Ho：这个看上去和高斯消元很像啊。

小Hi：没错，这个方程组叫异或方程组，它可以用和高斯消元同样的方法来解决。

其解答过程几乎和高斯消元无异，判定无解和多解的方式也相同。唯一需要注意的是消元过程不再是
高斯消元的加减，而是通过xor运算来进行消元。比如消除第j行第i列的1：

a[j][k] = a[j][k] xor a[i][k], y[j] = y[j] xor y[i]
其原理是：

    (a[j][1] * x[1]) xor (a[j][2] * x[2]) xor ... xor (a[j][30] * x[30]) 
xor (a[i][1] * x[1]) xor (a[i][2] * x[2]) xor ... xor (a[ i][30] * x[30]) 
= y[j] xor y[i]
<=> 
((a[j][1] * x[1]) xor (a[i][1] * x[1])) xor 
(((a[j][2] * x[2]) xor (a[i][2] * x[2]))) xor ... xor 
((a[j][30] * x[30]) xor (a[i][30] * x[30])) = y[j] xor y[i] 
<=> 
((a[j][1] xor a[i][1]) * x[1]) xor ((a[j][2] xor a[i][2]) * x[2]) xor ... 
((a[j][30] xor a[i][30]) * x[30]) = y[j] xor y[i]

而且由于给定游戏板是固定的，我们可以知道a[i][j]矩阵一定是固定的，而且通过计算可以知道我们消
元得到的上三角矩阵也是固定的，并且在这一次的问题中该上三角矩阵是满秩的，所以其一定存在唯一解。

所以我们一定有办法完成这个游戏。

小Ho：我明白了，我这就去写程序，这奖品我拿定了！
--------------------------------------------------------


输入
第1..5行：1个长度为6的字符串，表示该行的格子状态，1表示该格子是亮着的，0表示该格子是暗的。

保证一定存在解，且一定存在暗着的格子。

输出
需要按下的格子数量k，表示按下这k个位置后就可以将整个游戏板所有的格子都点亮。

接下来k行，每行一个坐标(x,y)，表示需要按下格子(x,y)。x坐标较小的先输出，若x相同，则先输出y坐标较小的。

样例输入
001111
011111
111111
111110 
111100

样例输出
2
1 1
5 6
*/

#include<bits/stdc++.h>
using namespace std;
const int N = 35;

int a[N][N]; //系数矩阵 a[i][j]=1表示按下灯i会改变灯j的状态

void show()
{
    for(int i=0; i<30; ++i)
    {
        printf("%d", a[i][0]);
        for(int j=1; j<=30; ++j) printf(" %d", a[i][j]);
        cout<<endl;
    }
    cout<<endl;
}

void init()
{
    for(int i=0; i<5; ++i)
    {
        for(int j=0; j<6; ++j)
        {
            int t1 = i*6+j;
            a[t1][t1] = 1;
            if(i-1 >=0 ) { a[(i-1)*6+j][t1] = 1; }
            if(i+1 < 5 ) { a[(i+1)*6+j][t1] = 1; }
            if(j-1 >=0 ) { a[i * 6 + j -1][t1] = 1;}
            if(j+1 < 6 ) { a[i*6+j+1][t1] = 1; }
        }
    }
}


int gauss(int M, int N)
{
    for(int i=0; i<N; ++i)
    {
        int r=i;
        while(r < M && a[r][i] == 0) ++r;
        if(r == M) return 0;
        if(r != i) swap(a[i], a[r]);

        for(int j=0; j<M; ++j)
        {
            if(a[j][i] && i != j) 
                for(int k=i; k<=N; ++k)
                    a[j][k] ^= a[i][k];
        }
    }
}

int main()
{
    #ifdef WFX
    freopen("in.txt","r",stdin);
    freopen("out.txt","w", stdout);
    #endif
    init();
    // show();
    
    char s[6];
    for(int i=0,id=0; i<5; ++i)
    {
        scanf("%s",s);
        for(int j=0; j<6; ++j) a[id++][30] = (s[j] == '1'? 0:1); //确定最后y[i]的值
    }
    // show();

    gauss(30,30);
    // show();

    int ans=0;
    stringstream ss;
    for(int i=0; i<30; ++i)
    {
        if(a[i][30])
        {
            ++ans;
            ss<<i/6+1<<' '<<i%6+1<<endl;
        }
    }
    cout<<ans<<endl<<ss.str();

    return 0;
}