/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
万圣节的早上，小Hi和小Ho在经历了一个小时的争论后，终于决定了如何度过这样有意义的一天——他们决定去闯鬼屋！
在鬼屋门口排上了若干小时的队伍之后，刚刚进入鬼屋的小Hi和小Ho都颇饥饿，于是他们决定利用进门前领到的地图，
找到一条通往终点的最短路径。
鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，
但是并不存在一条两端都是同一个地点的道路。那么小Hi和小Ho至少要走多少路程才能够走出鬼屋去吃东西呢？

提示：顺序！顺序才是关键。

输入
每个测试点（输入文件）有且仅有一组测试数据。
在一组测试数据中：
第1行为4个整数N、M、S、T，分别表示鬼屋中地点的个数和道路的条数，入口（也是一个地点）的编号，出口（同样也是一个地点）的编号。
接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条
长度为length_i的道路。
对于100%的数据，满足N<=10^3，M<=10^4, 1 <= length_i <= 10^3, 1 <= S, T <= N, 且S不等于T。
对于100%的数据，满足小Hi和小Ho总是有办法从入口通过地图上标注出来的道路到达出口。

输出
对于每组测试数据，输出一个整数Ans，表示那么小Hi和小Ho为了走出鬼屋至少要走的路程。

样例输入
5 23 5 4
1 2 708
2 3 112
3 4 721
4 5 339
5 4 960
1 5 849
2 5 98
1 4 99
2 4 25
2 1 200
3 1 146
3 2 106
1 4 860
4 1 795
5 4 479
5 4 280
3 4 341
1 4 622
4 2 362
2 3 415
4 1 904
2 1 716
2 5 575

样例输出
123

解题思路：
哎，好久没写dijkstra，都忘了在通过中间结点u更新其他结点时，只能更新与结点u直接相连的结点v，并且
v不在集合s中。重新整理一下dijkstra算法的思想：
dijkstra算法主要用于求单源最短路径，即从具有N个结点的图中的某一点S到其他任意点T的最短路径.
算法的过程如下：
用数组d[i]记录S到i的最短距离，p[i]记录S到i的最短路径上i的前驱结点。
初始时d[i]为S到i的边的距离，如果S到i没有直接相连的边，则初始距离设为一个足够大的正数INF。
过程中需要维护一个集合S,处于集合S中的点到S的最短距离都已经确定。
算法每次从S集合之外找一个距离S点距离最近的点u，即 s[u]==0 && d[u] = min{d[k]},k=1,2,,,,N。
将u加入集合S，然后用S到u的最短距离更新所有与u直接相连的结点到S的距离：
for v connected to u: d[v] = min(d[v], d[u] + g[u][v])
重复该过程直到所有结点都加入到集合s中为止。
*/

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn = 1e3+5;
const int INF = 1<<30;
int g[maxn][maxn];      
int s[maxn];
int d[maxn];
// int p[maxn]; //记录前驱结点
int N,M,S,T;

//时间复杂度O(N^2)
void dijkstra()
{
    for(int i=1; i<=N; ++i) d[i] = (g[S][i]? g[S][i] : INF);
    d[S] = 0;
    s[S] = 1;
    for(int i=1; i<=N; ++i)
    {
        int _min = INF,u;
        for(int j=1; j<=N; ++j)
        {
            if(!s[j] && d[j] < _min) _min = d[ u = j ];
        }
        if( d[u] == INF) break; //说明从起点S无法到达点u
        s[u] = 1; //将u放入结合s
        for(int v=1; v<=N; ++v)
        {
            //通过S到u的最短距离更新所有与u相连的结点到S的最短距离
            if(!s[v] && g[u][v] != INF)
            {
                d[v] = min(d[u] + g[u][v], d[v]);
                // p[v] = u; //在从S到T的最短路径上，v的前驱结点是u
            } 
        }
    }
}

int main()
{
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    int u,v,w;
    scanf("%d%d%d%d",&N,&M,&S,&T );
    //注意这看似是有向图，但其实是个无向图，虽然两个点之间可能有多条不同的边相连，
    //但每条路都是可以从一端到达另一端的。
    for(int i=1;i<=M; ++i)
    {
        scanf("%d%d%d",&u,&v,&w);
        if(g[u][v] == 0) g[u][v] = g[v][u] = w;
        else g[u][v] = g[v][u] = min(g[u][v] , w);
    }
    dijkstra();
    printf("%d\n", d[T]);

    return 0;
}