/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
小Hi和小Ho最近在玩一个解密类的游戏，他们需要控制角色在一片原始丛林里面探险，收集道具，并找到最后的宝藏。
现在他们控制的角色来到了一个很大的湖边。湖上有N个小岛(编号1..N)，以及连接小岛的M座木桥。每座木桥上各有一
个宝箱，里面似乎装着什么道具。

湖边还有一个船夫，船夫告诉主角。他可以载着主角到任意一个岛上，并且可以从任意一个岛上再载着主角回到湖边，
但是主角只有一次来回的机会。同时船夫告诉主角，连接岛屿之间的木桥很脆弱，走过一次之后就会断掉。

因为不知道宝箱内有什么道具，小Hi和小Ho觉得如果能把所有的道具收集齐肯定是最好的，那么对于当前岛屿和木桥
情况，能否将所有道具收集齐呢？

举个例子，比如一个由6个小岛和8座桥组成的地图：

week49_1.png

主角可以先到达4号小岛，然后按照4->1->2->4->5->6->3->2->5的顺序到达5号小岛，然后船夫到5号小岛将主角接回湖边。
这样主角就将所有桥上的道具都收集齐了。

提示：欧拉路的判定

输入
第1行：2个正整数，N,M。分别表示岛屿数量和木桥数量。1≤N≤10,000，1≤M≤50,000

第2..M+1行：每行2个整数，u,v。表示有一座木桥连接着编号为u和编号为v的岛屿，两个岛之间可能有多座桥。
1≤u,v≤N

输出
第1行：1个字符串，如果能收集齐所有的道具输出“Full”，否则输出”Part”。

样例输入
6 8
1 2
1 4
2 4
2 5
2 3
3 6
4 5
5 6

样例输出
Full

解题思路：
该题是无向图，中需要判断是否所有点的度为偶数或者只有两个点的度为奇数,还需要判断图是否是连通的。
在输入的时候计算所有点的度，并用并查集记录连通分量的个数。


相关知识：
来自：https://www.cnblogs.com/zhourongqing/archive/2012/09/18/2690088.html
欧拉路径和欧拉回路
欧拉路径：在图上用一种走法经过所有的边一次且只有一次的路径叫做欧拉路径。即一笔画。
欧拉回路：在欧拉路径的基础上又回到起点。
a、凡是由偶点组成的连通图，一定可以一笔画成。画时可以把任一偶点为起点，最后一定能以这个点为 
终点画完此图。 　　
b、凡是只有两个奇点的连通图（其余都为偶点），一定可以一笔画成。画时必须把一个奇点为起点，另 
一个奇点终点。 　
c、其他情况的图都不能一笔画出。(有偶数个奇点除以2便可算出此图需几笔画成。)

欧拉回路和欧拉路径的判断(整个图必须是连通的)
欧拉回路：
无向图：每个顶点的度数都是偶数，则存在欧拉回路。
有向图：每个顶点的入度都等于出度，则存在欧拉回路。
欧拉路径：
无向图：当且仅当该图所有顶点的度数为偶数 或者 除了两个度数为奇数外其余的全是偶数。
有向图：当且仅当该图所有顶点 出度=入度 或者 一个顶点 出度=入度+1，另一个顶点 入度=出度+1，其 
他顶点 出度=入度。

求欧拉路径和欧拉回路的路径可以用fleury，时间复杂度O（E）。
*/

#include<iostream>
#include<cstdio>
using namespace std;

const int maxn = 1e4+5;

int p[maxn]; //保存并查集
int deg[maxn]; //保存结点的度

int Find(int x){ return (p[x]==0 || p[x]==x)? p[x]=x : p[x]=Find(p[x]); }

void Union(int u,int v){ p[Find(u)] = Find(v); }

int main()
{
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    int N,M;
    int u,v;
    scanf("%d%d",&N,&M);
    while(M--)
    {
        scanf("%d%d",&u,&v);
        ++deg[u];
        ++deg[v];
        Union(u,v);
    }
    
    int odd=0, tree=0;
    for(int i=1; i<=N; ++i)
    {
        if(p[i] == i && ++tree > 1) break; //应用了短路与
        if((deg[i] & 1) && ++odd > 2) break; //应用了短路与
    }
    
    if(tree > 1) printf("Part\n");
    else printf("%s\n", (odd==0 || odd==2)? "Full":"Part");

    return 0;
}