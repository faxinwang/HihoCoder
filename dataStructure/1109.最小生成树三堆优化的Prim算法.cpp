/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
回到两个星期之前，在成功的使用Kruscal算法解决了问题之后，小Ho产生了一个疑问，究竟这样的算法在稀疏图上
比Prim优化之处在哪里呢？

-------------------------------------------------------------------------------------
提示：没有无缘无故的优化！
小Hi这时暂时完成了今天的游戏日常，回过头来对小Ho道：“其实主要是Prim算法本身还有很多需要优化的地方，
比如用堆就可以很好的解决求最小值部分和合并节点的问题。”。

小Ho想了想，道：“堆？求最小值的问题……让我想想，每次将1号节点与一个新的节点K合并的时候，等于是将原来
节点K相连的边统统改连到1号节点上，也就是1号节点新添加了几条边，在稀疏图的前提下，这样的边数其实不是
很多（或者说总和为O(M)级别的），但是在处理的过程中，由于不是针对稀疏图进行的优化，所以就没有很好的
处理这一点（因为如果不是稀疏图的话O(N^2)和O(M)其实是一样的），而是每次都在与1号点相连的所有边中选取
最短的边……所以说用堆优化的方法，其实就是用小根堆维护一个与1号节点相连的边的集合，然后每次在其中找出
最小的边，而将这条边连接的点加入到1号节点中，其实就是用新加入节点连接出的几条边去更新堆。”

小Hi点了点头：“对的，这就是为什么Prim算法在稀疏图上比Kruscal要慢的原因——本身就存在可以优化的地方，
那么你不妨思考一下，现在的时间复杂度是怎么样的呢？”

小Ho道：“Prim算法本身的时间复杂度是O(N^2)的，而在这个算法中，使用了堆来维护所有的边，操作数一共是
O(M)级别的，所以复杂度是O(MlogM)的！而Kruscal算法的时间复杂度是O(MlogM + M * Ackermann'(M))，
总的说来，是优化到了和Kruscal算法同样级别了呢。”

“没错！”小Hi笑道。
-------------------------------------------------------------------------------------

输入
每个测试点（输入文件）有且仅有一组测试数据。
在一组测试数据中：
第1行为2个整数N、M，表示小Hi拥有的城市数量和小Hi筛选出路线的条数。
接下来的M行，每行描述一条路线，其中第i行为3个整数N1_i, N2_i, V_i，分别表示这条路线的两个端点和在这条路线
上建造道路的费用。
对于100%的数据，满足N<=10^5, M<=10^6，于任意i满足1<=N1_i, N2_i<=N, N1_i≠N2_i, 1<=V_i<=10^3.
对于100%的数据，满足一定存在一种方案，使得任意两座城市都可以互相到达。

输出
对于每组测试数据，输出1个整数Ans，表示为了使任意两座城市都可以通过所建造的道路互相到达至少需要的建造费用。

样例输入
5 29
1 2 674
2 3 249
3 4 672
4 5 933
1 2 788
3 4 147
2 4 504
3 4 38
1 3 65
3 5 6
1 5 865
1 3 590
1 4 682
2 4 227
2 4 636
1 4 312
1 3 143
2 5 158
2 3 516
3 5 102
1 5 605
1 4 99
4 5 224
2 4 198
3 5 894
1 5 845
3 4 7
2 4 14
1 4 185

样例输出
92

解题思路：
做完这个题目之后，对prim算法有了更清晰的认识。现在在我的脑海中是这样的一副画面：
在一个平面或者立体的空间中，有N个黑色顶点通过N-1 ~ N(N-1)条浅灰色的边连接成了一个只有一个连通分量的图。
1.prim算法首先选择其中任意一个顶点，将该点染成红色(表示已经加入了生成树)，然后将所有与这个顶点
  相连的边染成黑色(作为候选边)。

2.然后从这些黑色的边中选出长度最短的一条，将该边和边上的另一个顶点都染成红色，表示该边和该顶点都加入了生成树。
  需要判断另外一个顶点是否已经染成了红色，如果已经染成了红色，说明该点已经在生成树中，则加入该边将导致环的出现。

3.然后再将与刚加入的顶点相连的所有边()染成黑色，然后再从所有黑色的边(注意是所有黑色的边，包括之前染黑的边)中
  选出长度最短的一条，重复步骤2的操作。直到已经选择了N-1条边(N个点).算法结束后，图中红色的边和顶点就构成了该
  图的最小生成树.
  
时间复杂度：
设图有N个顶点，E条边，则：
算法主要耗时部分在于通过循环从图中选取N-1条边，设从优先级队列中取出边的次数为K(N-1 <= k < E), 则取出
边需要KLog(E)的时间。每次选出一条边之后又会添加若干条边到优先级队列中，优先级中边的上限为E,所以加入边到
堆需要的时间为ELog(E)， 所以总共需要的时间为 KLog(E)+ELog(E)。所以堆优化的prim算法的时间复杂度为O(ELogE)。
但是这是一个比较粗略的估算，因为在prim算法中，边是逐渐添加到优先级队列中的，前期从优先级队列中取边的时候
队列中的边其实很少，所以取边需要的时间其实小于KLog(E)，而且在往优先队列中加入边的时候，可以过滤掉一些会导致
环的边，进而继续减小了K的值。 所以个人认为，堆优化的prim算法要更优于kruskal算法。虽然两者的时间复杂度都是
ELog(E).

空间复杂度：
堆优化的prim算法除了需要维护一个优先级度列O(E)外，还需要保存图的结构O(E)和一个长度为顶点个数N的辅助数组O(N),
所以堆优化的prim算法的空间复杂度为O(E).
*/

#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
const int maxn = 1e5+5;

struct Edge
{
    int v,w;
    Edge(int v, int w):v(v),w(w){}
    bool operator>(const Edge& e)const { return w > e.w; }
};

vector<Edge> g[maxn];
bool s[maxn];

int opt_prim(int N)
{
    int res = 0;
    priority_queue<Edge, deque<Edge>, greater<Edge> > Q;
    s[1] = 1;
    for(int i=0,n=g[1].size(); i<n; ++i) Q.push(g[1][i]);
    for(--N; N; ) //选择N-1条边
    {
        Edge e = Q.top(); Q.pop();
        if( s[e.v] ) continue; //如果该边的两个端点都已经在生成树中，继续处理下一个候选边
        //否则将该边和该边上的另外一个端点加入到生成树中去
        s[e.v] = 1; 
        res += e.w;
        --N; 
        
        //与新加入的点v相连的边都添加到优先级队列中去，作为候选边，需要注意的是，如果其中某条边的另外
        //一个端点已经在生成树中，那么这条边就不需要添加到优先级队列中去，因为加入该边会导致环的产生
        for(int i=0, v=e.v, n=g[v].size(); i<n; ++i)
        {
            if( !s[ g[v][i].v ]) Q.push( g[v][i] );
        }
    }
    return res;
}

int main()
{
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    int N,M;
    int u,v,w;
    scanf("%d%d",&N,&M);
    for(int i=0; i<M; ++i)
    {
        scanf("%d%d%d", &u, &v, &w);
        g[u].push_back(Edge(v,w));
        g[v].push_back(Edge(u,w));
    }
    printf("%d\n", opt_prim(N));

    return 0;
}
