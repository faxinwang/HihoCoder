/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
万圣节的中午，小Hi和小Ho在吃过中饭之后，来到了一个新的鬼屋！
鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，
但是并不存在一条两端都是同一个地点的道路。由于没有肚子的压迫，小Hi和小Ho决定好好的逛一逛这个鬼屋，
逛着逛着，小Hi产生了这样的问题：鬼屋中任意两个地点之间的最短路径是多少呢？

-------------------------------------------------------------
提示：其实如果你开心的话，完全可以从每个节点开始使用Dijstra算法_(:з」∠)_。
小Ho道：“你说的很有道理，我只需要从每个节点开始使用Dijstra算法就可以了！”

小Hi摇摇头道：“解决问题不是关键，学到知识才是关键，而且知识本身也远远没有掌握学习的方法重要！”

小Ho只得答道：“好的好的，听你说便是了!”

于是小Hi便开心道：“这次要说的算法叫做Floyd算法，是一种用于求图结构上任意两点间最短距离的算法！”

小Ho嘀咕道：“你都写标题上了，能不知道么？”

小Hi强行装作没听到，继续说道：“这个算法的核心之处在于数学归纳法——MinDistance(i, j)之间最短路径中可以
用到的节点是一点点增加的！”

“你这话每一个字我都听得懂，但是这句话为什么我听不懂呢……”小Ho无奈道。

“那我这么说吧，首先，最开始的时候，MinDistance(i, j)——即从第i个点到第j个点的最短路径的长度，拥有一个限制：
这条路径不能经过任何节点。”小Hi道。

“那就是说如果从i个点到第j个点之间没有直接相连的边的话，这个长度就是无穷大咯？”小Ho总结道：“只需要把输入
的边填进MinDistance中即可！”

“对！”小Hi满意于小Ho的上道，继续说道：“然后我放开限制，我允许MinDistance(i, j)——从第i个点到第j个点的最
短路径的长度，拥有的限制，变为：这条路径仅允许经过1号节点。”

“这个也简单，对于两个节点i, j，我只需要比较MinDistance(i, j)原来的值和MinDistance(i, 1)+MinDistance(1, j)的值，
取较小的一个作为新的MinDistance(i, j)就可以了——毕竟原来的MinDistance都是不经过任何节点，那么这样求出来的新的
MinDistance(i, j)只有可能经过1号节点。”

“那么接下来就是关键的了，我将限制继续放宽——路径仅允许经过1、2号节点。”小Hi继续说道。

“那其实也没有任何变化吧，对于两个节点i, j，我只需要比较MinDistance(i, j)原来的值和MinDistance(i, 2)+
MinDistance(2, j)的值，取较小的一个作为新的MinDistance(i, j)，之所以可以这样是因为，原来的MinDistance
都是在限制“仅允许经过1号节点”下，求出来的，所以新求出来的MinDistance(i, j)也只有可能经过1、2号节点！“

“那我继续放开限制呢？”小Hi问道。

“也没有什么区别了，每放开一个新的节点k允许作为路径中的节点，就对于任意的i, j，用MinDistance(i, k)+
MinDistance(k, j)去更新MinDistance(i, j)，直到1..N号节点都被添加进限制，此时也就等于没有限制了，
那么这个时候的MinDistance(i, j)就是我们所想要求的值，写成伪代码就是这样！”

for k = 1 .. N
    for i = 1 .. N 
        for j = 1 .. N
            若i, j, k各不相同
                MinDistance[i, j] = min{MinDistance[i, j], MinDistance[i, k] + MinDistance[k, j]}
“看来你已经很明白了呢！”小Hi嘿嘿一笑，往鬼屋深处跑了去——那么接下来就是小Ho利用求出的最短路径，去找到小Hi的时候了！
----------------------------------------------------------------------------

输入
每个测试点（输入文件）有且仅有一组测试数据。
在一组测试数据中：
第1行为2个整数N、M，分别表示鬼屋中地点的个数和道路的条数。
接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编
号为v_i的地点之间有一条长度为length_i的道路。
对于100%的数据，满足N<=10^2，M<=10^3, 1 <= length_i <= 10^3。
对于100%的数据，满足迷宫中任意两个地点都可以互相到达。

输出
对于每组测试数据，输出一个N*N的矩阵A，其中第i行第j列表示，从第i个地点到达第j个地点的最短路径的长度，
当i=j时这个距离应当为0。

样例输入
5 12
1 2 967
2 3 900
3 4 771
4 5 196
2 4 788
3 1 637
1 4 883
2 4 82
5 2 647
1 4 198
2 4 181
5 2 665

样例输出
0 280 637 198 394 
280 0 853 82 278 
637 853 0 771 967 
198 82 771 0 196 
394 278 967 196 0 

解题思路：
思路题目里面已经说的比较清楚了。只说一下需要注意的地方，就是在输入之前
需要将数组元素的值设为一个足够大的数字，且要保证这两个数字相加的时候不会发生
溢出。并且g[i][i]的值都为0.
*/

#include<iostream>
#include<cstdio>
using namespace std;
const int maxn = 105;
const int INF = 1<<20;
int g[maxn][maxn];

//时间复杂度: O(N^3)
void Floyd(int N)
{
    for(int k=1; k<=N; ++k)
    {
        for(int i=1; i<=N; ++i)
        {
            for(int j=1; j<=N; ++j) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
        }
    }
}

int main()
{
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    int N,M;
    int u,v,w;

    scanf("%d%d",&N,&M);
    for(int i=1; i<=N; ++i)
    {
        for(int j=1; j<=N; ++j) g[i][j] = INF;
        g[i][i] = 0;
    }

    while(M--)
    {
        scanf("%d%d%d",&u,&v,&w);
        if(g[u][v]) g[u][v] = g[v][u] = min(g[u][v], w);
        else  g[u][v] = g[v][u] = w;
    }
    
    
    Floyd(N);

    for(int i=1; i<=N; ++i)
    {
        for(int j=1; j<=N; ++j) printf("%d ",g[i][j]);
        printf("\n");
    }

    return 0;
}