/*
时间限制:10000ms
单点时限:1000ms
内存限制:256MB
描述
大家好，我是小Hi和小Ho的小伙伴Nettle，从这个星期开始由我来完成我们的Weekly。

新年回家，又到了一年一度大龄剩男剩女的相亲时间。Nettle去姑姑家玩的时候看到了一张姑姑写的相亲情况表，
上面都是姑姑介绍相亲的剩男剩女们。每行有2个名字，表示这两个人有一场相亲。由于姑姑年龄比较大了记性不是
太好，加上相亲的人很多，所以姑姑一时也想不起来其中有些人的性别。因此她拜托我检查一下相亲表里面有没有错
误的记录，即是否把两个同性安排了相亲。

OK，让我们愉快的暴力搜索吧！
才怪咧。
对于拿到的相亲情况表，我们不妨将其转化成一个图。将每一个人作为一个点(编号1..N)，若两个人之间有一场相亲，
则在对应的点之间连接一条无向边。(如下图)

因为相亲总是在男女之间进行的，所以每一条边的两边对应的人总是不同性别。假设表示男性的节点染成白色，女性的节
点染色黑色。对于得到的无向图来说，即每一条边的两端一定是一白一黑。如果存在一条边两端同为白色或者黑色，则表
示这一条边所表示的记录有误。

由于我们并不知道每个人的性别，我们的问题就转化为判定是否存在一个合理的染色方案，使得我们所建立的无向图满
足每一条边两端的顶点颜色都不相同。

那么，我们不妨将所有的点初始为未染色的状态。随机选择一个点，将其染成白色。再以它为起点，将所有相邻的点染成
黑色。再以这些黑色的点为起点，将所有与其相邻未染色的点染成白色。不断重复直到整个图都染色完成。(如下图)

在染色的过程中，我们应该怎样发现错误的记录呢？相信你一定发现了吧。对于一个已经染色的点，如果存在一个与它
相邻的已染色点和它的颜色相同，那么就一定存在一条错误的记录。(如上图的4，5节点)

到此我们就得到了整个图的算法：

选取一个未染色的点u进行染色
遍历u的相邻节点v：若v未染色，则染色成与u不同的颜色，并对v重复第2步；若v已经染色，如果 u和v颜色相同，
判定不可行退出遍历。若所有节点均已染色，则判定可行。接下来就动手写写吧！

输入
第1行：1个正整数T(1≤T≤10)
接下来T组数据，每组数据按照以下格式给出：
第1行：2个正整数N,M(1≤N≤10,000，1≤M≤40,000)
第2..M+1行：每行两个整数u,v表示u和v之间有一条边

输出
第1..T行：第i行表示第i组数据是否有误。如果是正确的数据输出”Correct”，否则输出”Wrong”

样例输入
2
5 5
1 2
1 3
3 4
5 2
1 5
5 5
1 2
1 3
3 4
5 2
3 5

样例输出
Wrong
Correct

解题思路：
就是判断是否可以使用两种颜色给图染色，使得任何相连的两个顶点颜色不同。相当于图的m着色问题中m=2时的情况。
使用DFS和BFS都可以，但时如果图很大(比如这里的1e4量级)，DFS可能会保证，所以这里使用了BFS.具体步骤为：
使用一个color辅助数组保存所有点的颜色(只有两种颜色，用0，1表示), 首先任意选择一个顶点放入队列中，并将
该顶点染成任意颜色，然后不断地从队列中取出顶点作为当前结点u，然后逐一处理与当前结点相连的所有结点v：
1.如果v没有染色，就将v染成与当前结点不同的另外一种颜色，并将v放入队列中。
2.如果v已被染色
    1.如果v与u的颜色相同，则该图不能划分为二分图。
    2.否则，继续处理下一个结点。
3.如果所有结点都已染色完毕任然不能判定无法划分，则该图可以判定为二分图。

注意：注意该图可能不止一个连通分量，所以可能需要从多个顶点开始进行BFS。
*/

#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
#include<cstring>
using namespace std;
const int maxn = 1e4+5;
const int maxm = maxn*4;

vector<int> g[maxn];
char color[maxn]; // 用0和1表示两个性别，初始为-1

bool BFS(int start)
{
    queue<int> Q;
    Q.push(start);
    color[start] = 0;
    while(!Q.empty())
    {
        int u = Q.front(); Q.pop();
        for(int i=0,n=g[u].size(); i<n; ++i)
        {
            int v = g[u][i];
            if(color[v] == color[u]) return false; //与当前相连节点的颜色相同
            if(color[v] != -1) continue; //已经染色过
            color[v] = (color[u]+1) % 2;
            Q.push(v);
        }
    }
    return true;
}

int main()
{
#ifdef WFX
freopen("in.txt","r",stdin);
#endif
    int T,N,M;
    int u,v;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&N,&M);
        for(int i=1; i<=N; ++i) g[i].clear();
        memset(color, -1, sizeof(color));

        for(int i=0; i<M; ++i)
        {
            scanf("%d%d",&u,&v);
            g[u].push_back(v);
            g[v].push_back(u);
        }
        bool correct = true;
        for(int i=1; i<=N; ++i)
        {
            if(color[i] != -1) continue;
            if(BFS(i) == false)
            {
                correct = false;
                break;
            } 
        }
        printf("%s\n", correct? "Correct" : "Wrong");
    }

    return 0;
}